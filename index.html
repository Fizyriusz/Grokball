<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Paintball MVP</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #timer { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
    </style>
</head>
<body>
    <div id="timer">Pozostały czas: 3:00</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scena i kamera
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Gracz (kamera jako postać)
        camera.position.set(0, 5, 10);
        let velocity = new THREE.Vector3();
        const speed = 0.1;
        const jumpSpeed = 0.3;
        let isJumping = false;

        // Mapa (podłoże + przeszkody)
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const obstacleGeometry = new THREE.BoxGeometry(2, 2, 2);
        const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
        const obstacles = [];
        for (let i = 0; i < 5; i++) {
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(Math.random() * 40 - 20, 1, Math.random() * 40 - 20);
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // NPC
        const npcGeometry = new THREE.BoxGeometry(1, 2, 1);
        const npcMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        const npc = new THREE.Mesh(npcGeometry, npcMaterial);
        npc.position.set(5, 1, 5);
        scene.add(npc);
        let npcDirection = new THREE.Vector3(0.05, 0, 0.05);

        // Pociski
        const bullets = [];
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });

        // Timer
        let timeLeft = 180; // 3 minuty w sekundach
        const timerElement = document.getElementById('timer');
        function updateTimer() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = Math.floor(timeLeft % 60);
            timerElement.textContent = `Pozostały czas: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            timeLeft -= 1;
            if (timeLeft < 0) alert("Koniec gry!");
        }

        // Sterowanie
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        document.addEventListener('click', () => {
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(camera.position);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            bullet.userData.velocity = direction.clone().multiplyScalar(0.5);
            scene.add(bullet);
            bullets.push(bullet);
        });

        // Kolizje
        function checkCollision(pos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(1, 2, 1));
            for (let obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) return true;
            }
            return false;
        }

        // Logika gry
        function animate() {
            requestAnimationFrame(animate);

            // Ruch gracza
            velocity.y -= 0.01; // Grawitacja
            if (keys['KeyW']) velocity.z -= speed;
            if (keys['KeyS']) velocity.z += speed;
            if (keys['KeyA']) velocity.x -= speed;
            if (keys['KeyD']) velocity.x += speed;
            if (keys['Space'] && !isJumping) {
                velocity.y = jumpSpeed;
                isJumping = true;
            }

            const newPos = camera.position.clone().add(velocity);
            if (!checkCollision(newPos)) camera.position.copy(newPos);
            if (camera.position.y <= 1) {
                camera.position.y = 1;
                velocity.y = 0;
                isJumping = false;
            }

            // Ruch NPC
            npc.position.add(npcDirection);
            if (npc.position.x > 20 || npc.position.x < -20) npcDirection.x *= -1;
            if (npc.position.z > 20 || npc.position.z < -20) npcDirection.z *= -1;

            // Pociski
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.userData.velocity);
                if (bullet.position.distanceTo(npc.position) < 1) {
                    scene.remove(npc); // "Zabicie" NPC
                    bullets.splice(index, 1);
                    scene.remove(bullet);
                }
                if (bullet.position.length() > 50) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            // Aktualizacja timera
            if (timeLeft >= 0) updateTimer();

            renderer.render(scene, camera);
        }
        animate();

        // Resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
