<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Paintball MVP</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #timer { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
        #score { position: absolute; top: 30px; left: 10px; color: white; font-family: Arial; }
        #hits { position: absolute; top: 50px; left: 10px; color: white; font-family: Arial; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; }
    </style>
</head>
<body>
    <div id="timer">Pozostały czas: 3:00</div>
    <div id="score">Punkty: 0</div>
    <div id="hits">Trafienia: 0</div>
    <div id="crosshair">+</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scena i kamera
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Gracz (kamera jako postać)
        camera.position.set(0, 5, 10);
        let velocity = new THREE.Vector3();
        const speed = 0.15;
        const jumpSpeed = 0.3;
        let isJumping = false;

        // Obracanie myszą
        let mouseSensitivity = 0.002;
        let pitch = 0;
        let yaw = 0;
        document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
        document.addEventListener('click', () => document.body.requestPointerLock());
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body) {
                yaw -= e.movementX * mouseSensitivity;
                pitch -= e.movementY * mouseSensitivity;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                camera.rotation.set(pitch, yaw, 0);
            }
        });

        // Mapa (podłoże + przeszkody)
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
        const obstacles = [];
        // Standardowe przeszkody
        for (let i = 0; i < 5; i++) {
            const obstacle = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), obstacleMaterial);
            obstacle.position.set(Math.random() * 40 - 20, 1, Math.random() * 40 - 20);
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        // Wyższe przeszkody
        for (let i = 0; i < 3; i++) {
            const obstacle = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2), obstacleMaterial);
            obstacle.position.set(Math.random() * 40 - 20, 2, Math.random() * 40 - 20);
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        // Niższe przeszkody
        for (let i = 0; i < 3; i++) {
            const obstacle = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), obstacleMaterial);
            obstacle.position.set(Math.random() * 40 - 20, 0.5, Math.random() * 40 - 20);
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        // Kilkupiętrowa przeszkoda
        const tower = new THREE.Mesh(new THREE.BoxGeometry(4, 6, 4), obstacleMaterial);
        tower.position.set(10, 3, 10);
        scene.add(tower);
        obstacles.push(tower);
        const platform = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 6), obstacleMaterial);
        platform.position.set(10, 5, 10);
        scene.add(platform);
        obstacles.push(platform);

        // NPC
        const npcGeometry = new THREE.BoxGeometry(1, 2, 1);
        const npcMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        const npcs = [];
        function spawnNPC() {
            const npc = new THREE.Mesh(npcGeometry, npcMaterial);
            npc.position.set(Math.random() * 40 - 20, 1, Math.random() * 40 - 20);
            npc.userData.direction = new THREE.Vector3((Math.random() - 0.5) * 0.1, 0, (Math.random() - 0.5) * 0.1);
            npc.userData.shootCooldown = 0;
            scene.add(npc);
            npcs.push(npc);
        }
        for (let i = 0; i < 2; i++) spawnNPC();

        // Pociski
        const bullets = [];
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        const npcBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xFF00FF });

        // Timer, punkty i trafienia
        let timeLeft = 180;
        let score = 0;
        let hits = 0;
        const timerElement = document.getElementById('timer');
        const scoreElement = document.getElementById('score');
        const hitsElement = document.getElementById('hits');
        function updateTimer() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = Math.floor(timeLeft % 60);
            timerElement.textContent = `Pozostały czas: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            if (timeLeft <= 0) {
                alert(`Koniec gry! Twój wynik: ${score}, Trafienia: ${hits}`);
                timeLeft = 0;
            }
        }
        const timerInterval = setInterval(() => {
            if (timeLeft > 0) {
                timeLeft -= 1;
                updateTimer();
            } else {
                clearInterval(timerInterval);
            }
        }, 1000);
        updateTimer();

        // Strzelanie NPC
        function npcShoot(npc) {
            if (npc.userData.shootCooldown <= 0) {
                const bullet = new THREE.Mesh(bulletGeometry, npcBulletMaterial);
                bullet.position.copy(npc.position);
                bullet.position.y = 1.5;
                const direction = camera.position.clone().sub(npc.position).normalize();
                bullet.userData.velocity = direction.clone().multiplyScalar(0.4);
                scene.add(bullet);
                bullets.push(bullet);
                npc.userData.shootCooldown = 45;
            }
            npc.userData.shootCooldown--;
        }

        // Sterowanie
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        document.addEventListener('click', () => {
            if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body) {
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.position.copy(camera.position);
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                bullet.userData.velocity = direction.clone().multiplyScalar(0.5);
                scene.add(bullet);
                bullets.push(bullet);
            }
        });

        // Kolizje gracza
        function checkCollision(pos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(1, 2, 1));
            for (let obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) return true;
            }
            return false;
        }

        // Kolizje pocisków
        function checkBulletCollision(bullet) {
            const bulletBox = new THREE.Box3().setFromCenterAndSize(bullet.position, new THREE.Vector3(0.4, 0.4, 0.4));
            for (let obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (bulletBox.intersectsBox(obstacleBox)) return true;
            }
            return false;
        }

        // Logika gry
        function animate() {
            requestAnimationFrame(animate);

            // Reset wektora prędkości
            velocity.set(0, velocity.y, 0);

            // Ruch gracza (S - przód, W - tył)
            velocity.y -= 0.01;
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const sideDirection = new THREE.Vector3();
            sideDirection.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();

            if (keys['KeyS']) velocity.add(direction.clone().multiplyScalar(-speed));
            if (keys['KeyW']) velocity.add(direction.clone().multiplyScalar(speed));
            if (keys['KeyA']) velocity.add(sideDirection.clone().multiplyScalar(-speed));
            if (keys['KeyD']) velocity.add(sideDirection.clone().multiplyScalar(speed));
            if (keys['Space'] && !isJumping) {
                velocity.y = jumpSpeed;
                isJumping = true;
            }

            const newPos = camera.position.clone().add(velocity);
            newPos.x = Math.max(-24, Math.min(24, newPos.x));
            newPos.z = Math.max(-24, Math.min(24, newPos.z));
            if (!checkCollision(newPos)) camera.position.copy(newPos);
            if (camera.position.y <= 1) {
                camera.position.y = 1;
                velocity.y = 0;
                isJumping = false;
            }

            // Ruch i strzelanie NPC
            npcs.forEach((npc, index) => {
                npc.position.add(npc.userData.direction);
                if (npc.position.x > 20 || npc.position.x < -20) npc.userData.direction.x *= -1;
                if (npc.position.z > 20 || npc.position.z < -20) npc.userData.direction.z *= -1;
                npcShoot(npc);
            });

            // Pociski
            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.userData.velocity);
                // Kolizja z przeszkodami
                if (checkBulletCollision(bullet)) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                    return;
                }
                // Trafienie NPC przez gracza
                if (bullet.material.color.getHex() === 0xFFFF00) {
                    npcs.forEach((npc, npcIndex) => {
                        if (bullet.position.distanceTo(npc.position) < 1) {
                            scene.remove(npc);
                            npcs.splice(npcIndex, 1);
                            bullets.splice(index, 1);
                            scene.remove(bullet);
                            score += 1;
                            scoreElement.textContent = `Punkty: ${score}`;
                            spawnNPC();
                        }
                    });
                }
                // Trafienie gracza przez NPC
                if (bullet.material.color.getHex() === 0xFF00FF && bullet.position.distanceTo(camera.position) < 1) {
                    hits += 1;
                    hitsElement.textContent = `Trafienia: ${hits}`;
                    bullets.splice(index, 1);
                    scene.remove(bullet);
                }
                if (bullet.position.length() > 50) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        // Resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
